package world.hachimi.app.ui.component

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.aspectRatio
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.selection.SelectionContainer
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.text.AnnotatedString
import androidx.compose.ui.text.LinkAnnotation
import androidx.compose.ui.text.LinkInteractionListener
import androidx.compose.ui.text.SpanStyle
import androidx.compose.ui.text.TextLinkStyles
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextDecoration
import androidx.compose.ui.text.withLink
import androidx.compose.ui.text.withStyle
import androidx.compose.ui.unit.dp
import androidx.compose.ui.util.fastForEach
import coil3.compose.AsyncImage
import coil3.compose.LocalPlatformContext
import coil3.request.ImageRequest
import coil3.request.crossfade
import world.hachimi.app.ui.design.HachimiTheme
import world.hachimi.app.ui.design.components.LocalContentColor
import world.hachimi.app.ui.design.components.LocalTextStyle
import world.hachimi.app.ui.design.components.Text
import world.hachimi.app.util.fillMaxWidthIn

/**
 * Warning: Do not touch these fucking codes, it's generated by GPT-5.2
 *
 * Very small Markdown renderer for event posts.
 *
 * Supported:
 * - Headings: # / ## / ###
 * - Bold: **text** (single-line)
 * - Links: [title](https://...)
 * - Images (block only): a whole line formatted as ![alt](url)
 * - Paragraphs + blank line separation
 */
@Composable
fun MarkdownText(
    markdown: String,
    modifier: Modifier = Modifier,
    onUrlClick: (String) -> Unit,
) {
    val style = LocalTextStyle.current
    val contentColor = LocalContentColor.current
    val linkColor = HachimiTheme.colorScheme.primary

    val linkInteractionListener = remember(onUrlClick) {
        object : LinkInteractionListener {
            override fun onClick(link: LinkAnnotation) {
                val url = (link as? LinkAnnotation.Url)?.url ?: return
                onUrlClick(url)
            }
        }
    }

    val blocks = remember(markdown, style, contentColor, linkColor, linkInteractionListener) {
        parseMarkdownBlocks(
            markdown = markdown,
            baseColor = contentColor,
            linkColor = linkColor,
            linkInteractionListener = linkInteractionListener,
        )
    }

    val ctx = LocalPlatformContext.current

    SelectionContainer {
        Column(
            modifier = modifier,
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            blocks.fastForEach { block ->
                when (block) {
                    is MarkdownBlock.Text -> {
                        Text(
                            text = block.text,
                            style = style,
                        )
                    }

                    is MarkdownBlock.Image -> {
                        Surface(
                            Modifier.fillMaxWidthIn(maxWidth = 512.dp).aspectRatio(16f / 9f).padding(top = 4.dp),
                            color = LocalContentColor.current.copy(0.12f),
                            shape = RoundedCornerShape(16.dp)
                        ) {
                            AsyncImage(
                                model = ImageRequest.Builder(ctx)
                                    .data(block.url)
                                    .crossfade(true)
                                    .build(),
                                contentDescription = block.alt,
                                modifier = Modifier.fillMaxSize(),
                                contentScale = ContentScale.Crop,
                            )
                        }
                        Text(
                            modifier = Modifier.align(Alignment.CenterHorizontally),
                            text = block.alt,
                            style = MaterialTheme.typography.labelSmall
                        )
                    }

                    is MarkdownBlock.UnorderedList -> {
                        MarkdownUnorderedList(items = block.items)
                    }
                }
            }
        }
    }
}

private sealed interface MarkdownBlock {
    data class Text(val text: AnnotatedString) : MarkdownBlock
    data class Image(val alt: String, val url: String) : MarkdownBlock
    data class UnorderedList(val items: List<AnnotatedString>) : MarkdownBlock
}

private fun parseMarkdownBlocks(
    markdown: String,
    baseColor: Color,
    linkColor: Color,
    linkInteractionListener: LinkInteractionListener,
): List<MarkdownBlock> {
    val lines = markdown.replace("\r\n", "\n").replace("\r", "\n").lines()

    // Block-level image only: `![alt](url)` on a single line (ignoring trailing spaces)
    val imageLineRegex = Regex("^!\\[(.*?)]\\((.*?)\\)\\s*$")

    // Unordered list item: "- xxx" / "* xxx" / "• xxx"
    val ulLineRegex = Regex("^\\s*([-*]|•)\\s+(.*)$")

    val blocks = mutableListOf<MarkdownBlock>()

    // Accumulate paragraph lines and flush into one AnnotatedString block.
    val paragraph = mutableListOf<String>()
    // Accumulate list items
    val ulItems = mutableListOf<String>()

    fun flushParagraph() {
        if (paragraph.isEmpty()) return
        val paragraphText = paragraph.joinToString(" ") { it.trim() }.trim()
        if (paragraphText.isNotBlank()) {
            val annotated = markdownLineToAnnotatedString(
                line = paragraphText,
                baseColor = baseColor,
                linkColor = linkColor,
                linkInteractionListener = linkInteractionListener
            )
            blocks += MarkdownBlock.Text(annotated)
        }
        paragraph.clear()
    }

    fun flushUnorderedList() {
        if (ulItems.isEmpty()) return
        val items = ulItems.map { itemText ->
            markdownLineToAnnotatedString(
                line = itemText,
                baseColor = baseColor,
                linkColor = linkColor,
                linkInteractionListener = linkInteractionListener
            )
        }
        blocks += MarkdownBlock.UnorderedList(items)
        ulItems.clear()
    }

    for (rawLine in lines) {
        val line = rawLine.trimEnd()

        // Blank -> paragraph/list break
        if (line.isBlank()) {
            flushParagraph()
            flushUnorderedList()
            continue
        }

        // Image-only line -> flush text/list, then add image block
        val imageMatch = imageLineRegex.matchEntire(line)
        if (imageMatch != null) {
            flushParagraph()
            flushUnorderedList()
            val alt = imageMatch.groups[1]?.value.orEmpty()
            val url = imageMatch.groups[2]?.value.orEmpty()
            blocks += MarkdownBlock.Image(alt = alt, url = url)
            continue
        }

        // List item -> flush paragraph, accumulate list
        val ulMatch = ulLineRegex.matchEntire(line)
        if (ulMatch != null) {
            flushParagraph()
            val content = ulMatch.groups[2]?.value.orEmpty()
            ulItems += content
            continue
        } else {
            // Non-list line ends an existing list block
            flushUnorderedList()
        }

        // Heading line -> flush paragraph and emit heading as its own text block
        val headingLevel = when {
            line.startsWith("### ") -> 3
            line.startsWith("## ") -> 2
            line.startsWith("# ") -> 1
            else -> 0
        }
        if (headingLevel > 0) {
            flushParagraph()
            val headingText = line.drop(headingLevel + 1)
            val annotated = buildAnnotatedString {
                withStyle(
                    SpanStyle(
                        fontWeight = FontWeight.SemiBold,
                        color = baseColor,
                    )
                ) {
                    append(headingText)
                }
            }
            blocks += MarkdownBlock.Text(annotated)
            continue
        }

        // Normal line: keep accumulating into current paragraph
        paragraph += line
    }

    flushParagraph()
    flushUnorderedList()
    return blocks
}

private fun markdownLineToAnnotatedString(
    line: String,
    baseColor: Color,
    linkColor: Color,
    linkInteractionListener: LinkInteractionListener,
): AnnotatedString = buildAnnotatedString {
    appendInlineMarkdown(
        text = line,
        baseColor = baseColor,
        linkColor = linkColor,
        linkInteractionListener = linkInteractionListener,
    )
}

private fun AnnotatedString.Builder.appendInlineMarkdown(
    text: String,
    baseColor: Color,
    linkColor: Color,
    linkInteractionListener: LinkInteractionListener,
) {
    var i = 0
    while (i < text.length) {
        // Link: [title](url)
        if (text[i] == '[') {
            val closeBracket = text.indexOf(']', startIndex = i + 1)
            val openParen = if (closeBracket != -1) text.indexOf('(', startIndex = closeBracket + 1) else -1
            val closeParen = if (openParen != -1) text.indexOf(')', startIndex = openParen + 1) else -1
            if (closeBracket != -1 && openParen == closeBracket + 1 && closeParen != -1) {
                val title = text.substring(i + 1, closeBracket)
                val url = text.substring(openParen + 1, closeParen)

                withLink(LinkAnnotation.Url(url, TextLinkStyles(), linkInteractionListener)) {
                    withStyle(
                        SpanStyle(
                            color = linkColor,
                            textDecoration = TextDecoration.Underline,
                        )
                    ) {
                        append(title)
                    }
                }

                i = closeParen + 1
                continue
            }
        }

        // Bold: **text**
        if (i + 1 < text.length && text[i] == '*' && text[i + 1] == '*') {
            val close = text.indexOf("**", startIndex = i + 2)
            if (close != -1) {
                val boldText = text.substring(i + 2, close)
                withStyle(SpanStyle(fontWeight = FontWeight.SemiBold, color = baseColor)) {
                    append(boldText)
                }
                i = close + 2
                continue
            }
        }

        append(text[i])
        i++
    }
}

@Composable
private fun MarkdownUnorderedList(
    items: List<AnnotatedString>,
    modifier: Modifier = Modifier,
) {
    Column(modifier = modifier, verticalArrangement = Arrangement.spacedBy(6.dp)) {
        items.forEach { item ->
            Row(modifier = Modifier.fillMaxWidthIn()) {
                Text(text = "•")
                Spacer(Modifier.width(8.dp))
                Text(
                    modifier = Modifier.weight(1f),
                    text = item,
                )
            }
        }
    }
}
